# Model Testing

Model-based testing is a method of testing
a system by applying commands that modify
the state of the application, and verifying
that the output matches what is expected
for each action.

Performing model-based testing with fast-check
means that the commands issued to the model 
are generated by an Arbitrary, allowing easier
testing of cumulative state changes.

There are a few different ways you can compose
your model-based test using the following interfaces:

```fsharp
type ICommand<'Model,'Real> =
    /// Check if the model is in the right state to apply the command.
    abstract check: m: 'Model -> bool

    /// Receive the non-updated model and the real or system under test.
    ///
    /// Perform the checks post-execution - Throw in case of invalid state.
    ///
    /// Update the model accordingly.
    abstract run: m: 'Model * r: 'Real -> unit

    /// Name of the command.
    abstract toString: unit -> string

type IAsyncCommand<'Model,'Real> =
    /// Check if the model is in the right state to apply the command.
    abstract check: m: 'Model -> Async<bool>

    /// Receive the non-updated model and the real or system under test.
    ///
    /// Perform the checks post-execution - Throw in case of invalid state.
    ///
    /// Update the model accordingly.
    abstract run: m: 'Model * r: 'Real -> Async<unit>

    /// Name of the command.
    abstract toString: unit -> string

type IPromiseCommand<'Model,'Real> =
    /// Check if the model is in the right state to apply the command.
    abstract check: m: 'Model -> JS.Promise<bool>

    /// Receive the non-updated model and the real or system under test.
    ///
    /// Perform the checks post-execution - Throw in case of invalid state.
    ///
    /// Update the model accordingly.
    abstract run: m: 'Model * r: 'Real -> JS.Promise<unit>

    /// Name of the command.
    abstract toString: unit -> string

type ICommandWrapper<'Model,'Real> =
    inherit ICommand<'Model,'Real>

    /// The command to run.
    abstract cmd: ICommand<'Model,'Real>

    /// Indicates if the command has been executed.
    abstract hasRan: bool with get, set

    /// Create a clone of this command.
    abstract clone: unit -> ICommandWrapper<'Model,'Real>

type IAsyncCommandWrapper<'Model,'Real> =
    inherit IAsyncCommand<'Model,'Real>

    /// The command to run.
    abstract cmd: IAsyncCommand<'Model,'Real>

    /// Indicates if the command has been executed.
    abstract hasRan: bool with get, set

    /// Create a clone of this command.
    abstract clone: unit -> IAsyncCommandWrapper<'Model,'Real>

type IPromiseCommandWrapper<'Model,'Real> =
    inherit IAsyncCommand<'Model,'Real>

    /// The command to run.
    abstract cmd: IAsyncCommand<'Model,'Real>

    /// Indicates if the command has been executed.
    abstract hasRan: bool with get, set

    /// Create a clone of this command.
    abstract clone: unit -> IPromiseCommandWrapper<'Model,'Real>

type ICommandSeq<'Model,'Real> =
    inherit seq<ICommandWrapper<'Model,'Real>>

    /// Collection of commandwrappers.
    abstract commands: ResizeArray<ICommandWrapper<'Model,'Real>>

    /// The meta-data given for a replay.
    abstract metadataForReplay: (unit -> string)

    /// Clone the command seq.
    abstract clone: unit -> ICommandSeq<'Model,'Real>

    /// The string representation of the command seq.
    abstract toString: unit -> string

type IAsyncCommandSeq<'Model,'Real> =
    inherit seq<IAsyncCommandWrapper<'Model,'Real>>

    /// Collection of commandwrappers.
    abstract commands: ResizeArray<IAsyncCommandWrapper<'Model,'Real>>

    /// The meta-data given for a replay.
    abstract metadataForReplay: (unit -> string)

    /// Clone the command seq.
    //[<Emit("[cloneMethod]()")>]
    abstract clone: unit -> IAsyncCommandSeq<'Model,'Real>

    /// The string representation of the command seq.
    abstract toString: unit -> string

type IPromiseCommandSeq<'Model,'Real> =
    inherit seq<IAsyncCommandWrapper<'Model,'Real>>

    /// Collection of commandwrappers.
    abstract commands: ResizeArray<IAsyncCommandWrapper<'Model,'Real>>

    /// The meta-data given for a replay.
    abstract metadataForReplay: (unit -> string)

    /// Clone the command seq.
    abstract clone: unit -> IPromiseCommandSeq<'Model,'Real>

    /// The string representation of the command seq.
    abstract toString: unit -> string
```

To do this in fast-check you must first either
already have or define a model to test:

```fsharp
type Model () = 
    let mutable count = 0

    member _.Count = 
        let count = count
        count

    member _.Decrement () = count <- count - 1

    member _.Increment () = count <- count + 1
```

The commands for this test will be an Arbitrary
that executes `Decrement()` and `Increment()` and
then validating the resulting state of the model
with what the expected state (these are your tests).

To make things easier you can add these:

```fsharp
type Msg =
    | Decrement
    | Increment

let update msg (model: Model) =
    match msg with
    | Decrement -> model.Decrement()
    | Increment -> model.Increment()
```

Once we define a Msg to represent our commands and 
update function to create a mapping of Msg to 
the method we want to apply it's time to create the
commands to be transformed into an Arbitrary:

```fsharp
type DecrementCommand () =
    interface ICommand<Model, Model> with
        member _.check (m: Model) = true
        member _.run (m: Model, r: Model) =
            update Decrement r
            Jest.expect(r.Count).toBeLessThanOrEqual(m.Count)
            m.Decrement()
        
        member _.toString () = "Decrement"

type IncrementCommand () =
    interface ICommand<Model, Model> with
        member _.check (m: Model) = true
        member _.run (m: Model, r: Model) =
            update Increment r
            Jest.expect(r.Count).toBeGreaterThanOrEqual(m.Count)
            m.Increment()
        
        member _.toString () = "Increment" 
```

All commands must interface either `ICommand<'Model,'Real>`
or `IAsyncCommand<'Model,'Real>`. Once we have these we can
now create the actual Arbitrary:

```fsharp
let commandArb = Arbitrary.commands [ 
    Arbitrary.constant (DecrementCommand() :> ICommand<Model,Model>)
    Arbitrary.constant (IncrementCommand() :> ICommand<Model,Model>) 
]
```

Doing this all using async would look like this:

```fsharp
type AsyncDecrementCommand () =
    interface IAsyncCommand<Model, Model> with
        member _.check (m: Model) = async { return true }
        member _.run (m: Model, r: Model) =
            async {
                update Decrement r
                Jest.expect(r.Count).toBeLessThanOrEqual(m.Count)
                m.Decrement()
            }
        
        member _.toString () = "Decrement" 

type AsyncIncrementCommand () =
    interface IAsyncCommand<Model, Model> with
        member _.check (m: Model) = async { return true }
        member _.run (m: Model, r: Model) =
            async {
                update Increment r
                Jest.expect(r.Count).toBeGreaterThanOrEqual(m.Count)
                m.Increment()
            }
        
        member _.toString () = "Increment" 

let asyncCommandArb = Arbitrary.asyncCommands [ 
    Arbitrary.constant (AsyncDecrementCommand() :> IAsyncCommand<Model,Model>)
    Arbitrary.constant (AsyncIncrementCommand() :> IAsyncCommand<Model,Model>) 
]

```

Doing this all using promises would look like this:

```fsharp
type PromiseDecrementCommand () =
    interface IPromiseCommand<Model, Model> with
        member _.check (m: Model) = promise { return true }
        member _.run (m: Model, r: Model) =
            promise {
                update Decrement r
                Jest.expect(r.Count).toBeLessThanOrEqual(m.Count)
                m.Decrement()
            }
        
        member _.toString () = "Decrement" 

type PromiseIncrementCommand () =
    interface IPromiseCommand<Model, Model> with
        member _.check (m: Model) = promise { return true }
        member _.run (m: Model, r: Model) =
            promise {
                update Increment r
                Jest.expect(r.Count).toBeGreaterThanOrEqual(m.Count)
                m.Increment()
            }
        
        member _.toString () = "Increment" 

let promiseCommandArb = Arbitrary.promiseCommands [ 
    Arbitrary.constant (PromiseDecrementCommand() :> IPromiseCommand<Model,Model>)
    Arbitrary.constant (PromiseIncrementCommand() :> IPromiseCommand<Model,Model>) 
]
```

<Note>`Jest.expect` is not required here, the function just
needs to throw in the event of a (test) failure.</Note>

Finally once we have all of these pieces put together it's 
time to run our tests. Depending on if you're running
`ICommand` or `IAsyncCommand` you will use [asyncModelRun](/fast-check#asyncmodelrun)
or [modelRun](/fast-check#modelrun).

```fsharp
// If you're using Fable.FastCheck.Jest
Jest.test.prop("Running some commands", commandArb, fun cmds ->
    FastCheck.modelRun(Model(), Model(), cmds)
)

Jest.test("Running some commands", fun () ->
    FastCheck.assert'(FastCheck.property(commandArb, fun cmds ->
        FastCheck.modelRun(Model(), Model(), cmds)
    ))
)
```

For our async-based commands:

```fsharp
// If you're using Fable.FastCheck.Jest
Jest.test.prop("Running some commands", asyncCommandArb, fun cmds ->
    FastCheck.asyncModelRun(Model(), Model(), cmds)
)

Jest.test("Running some commands", fun () ->
    FastCheck.assert'(FastCheck.asyncProperty(asyncCommandArb, fun cmds ->
        FastCheck.asyncModelRun(Model(), Model(), cmds)
    ))
)
```

For our promise-based commands:

```fsharp
// If you're using Fable.FastCheck.Jest
Jest.test.prop("Running some commands", promiseCommandArb, fun cmds ->
    FastCheck.promiseModelRun(Model(), Model(), cmds)
)

Jest.test("Running some commands", fun () ->
    FastCheck.assert'(FastCheck.promiseProperty(promiseCommandArb, fun cmds ->
        FastCheck.promiseModelRun(Model(), Model(), cmds)
    ))
)
```
