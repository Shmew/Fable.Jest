namespace Fable.FastCheck

open Fable.Core

/// A Shrinkable<T, TShrink = T> holds an internal value of type `T`
/// and can shrink it to smaller `TShrink` values
type Shrinkable<'T> =
    abstract value_ : 'T

    abstract shrink: unit -> seq<Shrinkable<'T>>

    /// State storing the result of hasCloneMethod
    /// If <true> the value will be cloned each time it gets accessed
    abstract hasToBeCloned : bool

    /// Safe value of the shrinkable
    /// Depending on hasToBeCloned it will either be value_ or a clone of it
    abstract value : 'T

    /// Create another shrinkable by mapping all values using the provided `mapper`
    /// Both the original value and the shrunk ones are impacted
    /// Map function, to produce a new element based on an old one
    abstract map: mapper: ('T -> 'U) -> Shrinkable<'U>

    /// Create another shrinkable
    /// by filtering its shrunk values against `predicate`
    /// 
    /// All the shrunk values produced by the resulting `Shrinkable<T>`
    /// satisfy `predicate(value) == true`
    /// Predicate, to test each produced element. Return true to keep the element, false otherwise
    abstract filter: predicate: ('T -> bool) -> Shrinkable<'T>

type Shrinkable =
    [<Emit("new Shrinkable($1...)")>]
    static member Create (value_: 'T, ?shrink: (unit -> seq<Shrinkable<'T>>)) : Shrinkable<'T> = jsNative

type Arbitrary<'T> =
    /// Generate a value of type `T` along with its shrink method
    /// based on the provided random number generator
    /// Random number generator
    abstract generate: mrng: Random -> Shrinkable<'T>

    /// Create another arbitrary by filtering values against `predicate`
    /// 
    /// All the values produced by the resulting arbitrary
    /// satisfy `predicate(value) == true`
    /// Predicate, to test each produced element. Return true to keep the element, false otherwise
    abstract filter: predicate: ('T -> bool) -> Arbitrary<'T>

    /// Create another arbitrary by mapping all produced values using the provided `mapper`
    /// Values produced by the new arbitrary are the result of applying `mapper` value by value
    /// <param name="mapper">Map function, to produce a new element based on an old one
    abstract map: mapper: ('T -> 'U) -> Arbitrary<'U>

    /// Create another arbitrary by mapping a value from a base Arbirary using the provided `fmapper`
    /// Values produced by the new arbitrary are the result of the arbitrary generated by applying `fmapper` to a value
    /// Chain function, to produce a new Arbitrary using a value from another Arbitrary
    [<Emit("$0.chain($1)")>]
    abstract bind: fmapper: ('T -> Arbitrary<'U>) -> Arbitrary<'U>

    /// Create another Arbitrary with no shrink values
    abstract noShrink: unit -> Arbitrary<'T>

    /// Create another Arbitrary having bias - by default return itself
    abstract withBias: freq: float -> Arbitrary<'T>

    /// Create another Arbitrary that cannot be biased
    abstract noBias: unit -> Arbitrary<'T>

type ArbitraryWithShrink<'T> =
    inherit Arbitrary<'T>

    /// Produce a stream of shrinks of value
    /// Value to shrink
    /// Indicate whether its the first shrink (default: false)
    abstract shrink: value: 'T * ?shrunkOnce: bool -> seq<'T>

    /// Build the Shrinkable associated to value
    /// Value to shrink
    /// Indicate whether its the first shrink
    abstract shrinkableFor: value: 'T * ?shrunkOnce: bool -> Shrinkable<'T>
